<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Navegación con OpenLayers estilo GPS</title>

  <!-- OpenLayers v10.x desde CDN -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>

  <style>
    html, body { margin: 0; height: 100%; }
    #map      { width: 100%; height: 100%; }

    /* El icono del vehículo: se ancla al pixel deseado */
    .car {
      width: 32px;
      height: 32px;
      background: url('https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/examples/data/icon.png')
                  center/contain no-repeat;
      transform: translate(-50%, -50%);          /* centrar en el punto */
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    /***** 1. TRAZADO DE LA CARRETERA *****/
    // Sustituye estas coordenadas por las de tu calle/carretera (lon, lat WGS-84)
    const routeLonLat = [
      [-5.99347, 37.38909],
      [-5.99226, 37.38942],
      [-5.99105, 37.38970],
      [-5.98986, 37.39002],
      [-5.98869, 37.39036],
      [-5.98751, 37.39070],
      [-5.98631, 37.39107]
    ];

    // Proyección a Web Mercator (la que usa OpenLayers por defecto)
    const routeCoords = routeLonLat.map(c => ol.proj.fromLonLat(c));

    const routeFeature = new ol.Feature(new ol.geom.LineString(routeCoords));
    routeFeature.setStyle(new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: '#ffcc00',
        width: 6
      })
    }));

    const routeLayer = new ol.layer.Vector({
      source: new ol.source.Vector({ features: [routeFeature] })
    });

    /***** 2. CAPA BASE Y MAPA *****/
    const map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({ source: new ol.source.OSM() }),
        routeLayer
      ],
      view: new ol.View({
        center: routeCoords[0],
        zoom: 18,          // Ajusta si el nivel es muy alto o bajo
        rotation: 0
      })
    });

    /***** 3. ICONO DEL VEHÍCULO (OVERLAY) *****/
    const carEl = document.createElement('div');
    carEl.className = 'car';
    // Overlay con posicionamiento por coordenadas, pero el centering lo manejamos con view.centerOn
    const carOverlay = new ol.Overlay({
      element: carEl,
      positioning: 'center-center',
      stopEvent: false,
      rotateWithView: true      // El coche NO gira; el mapa sí
    });
    map.addOverlay(carOverlay);

    /***** 4. ANIMACIÓN DE NAVEGACIÓN *****/
    let index = 0;               // Punto actual en la ruta
    const fps = 60;              // Fluidez
    const metersPerTick = 4;     // Velocidad (~4 m por frame => ~1 km/min a 60 fps)

    /** Calcula el rumbo geodésico entre dos puntos EPSG:3857 en radianes */
    function bearing(p1, p2) {
      const lon1 = p1[0], lat1 = p1[1];
      const lon2 = p2[0], lat2 = p2[1];
      return Math.atan2(lon2 - lon1, lat2 - lat1);
    }

    /** Desplaza el coche a la coordenada indicada y ajusta vista/rotación */
    function goTo(coordinate, headingRad) {
      carOverlay.setPosition(coordinate);

      // Fijar el coche al 75% de la altura de pantalla
      const size = map.getSize();
      map.getView().centerOn(coordinate, size, [size[0] / 2, size[1] * 0.75]);

      // Rotar el mapa para que el heading mire “hacia arriba”
      map.getView().setRotation(-headingRad);
    }

    /** Bucle principal */
    function animate() {
      const current   = routeCoords[index];
      const nextIndex = index + 1 < routeCoords.length ? index + 1 : 0;
      const next      = routeCoords[nextIndex];

      const dx = next[0] - current[0];
      const dy = next[1] - current[1];
      const dist = Math.hypot(dx, dy);

      if (dist < metersPerTick) {
        // Llegamos al siguiente vértice
        index = nextIndex;
      } else {
        // Avanza un pequeño paso hacia el siguiente punto
        const stepRatio = metersPerTick / dist;
        routeCoords[index][0] += dx * stepRatio;
        routeCoords[index][1] += dy * stepRatio;
      }

      // Actualiza posición y rotación
      const hdg = bearing(current, next);
      goTo(current, hdg);

      requestAnimationFrame(animate);
    }

    // Empieza la animación
    goTo(routeCoords[0], 0);
    animate();
  </script>
</body>
</html>
