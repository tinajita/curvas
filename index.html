<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Metadatos para una experiencia de app a pantalla completa en iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Avisador">
    
    <title>Avisador de Curvas Automático</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        #app-screen { transition: background-color 0.5s ease-in-out; }
        .status-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        /* Estilos base para los botones de modo de conducción */
        .mode-button {
            @apply px-6 py-3 rounded-full text-lg font-bold shadow-lg transition-all duration-300 ease-in-out;
            @apply flex items-center justify-center; /* Para centrar el texto si es necesario */
        }
        /* Estilos específicos para el botón Confort */
        #mode-comfort {
            @apply bg-green-600 text-white hover:bg-green-700 active:bg-green-800;
        }
        #mode-comfort.selected {
            @apply ring-4 ring-green-400; /* Anillo al seleccionar */
        }
        /* Estilos específicos para el botón Sport */
        #mode-sport {
            @apply bg-red-600 text-white hover:bg-red-700 active:bg-red-800;
        }
        #mode-sport.selected {
            @apply ring-4 ring-red-400; /* Anillo al seleccionar */
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen">

    <!-- La app ocupa toda la pantalla -->
    <div id="app-screen" class="w-full h-full fixed top-0 left-0 flex flex-col text-white p-6 bg-blue-800">
        
        <!-- Controles de modo de conducción - Separados y con diseño mejorado -->
        <div class="w-full flex justify-between items-center px-4 pt-4 absolute top-0 left-0 z-20">
            <button id="mode-comfort" class="mode-button selected" data-mode="comfort">Confort</button>
            <button id="mode-sport" class="mode-button" data-mode="sport">Sport</button>
        </div>

        <div class="flex-grow flex flex-col items-center justify-between z-10 pt-24 pb-8"> <!-- Ajuste de padding para los botones superiores -->
            <!-- Sección Superior: Curva -->
            <div class="w-full flex-grow flex flex-col items-center justify-center">
                <svg viewBox="0 0 100 100" class="w-40 h-40">
                    <path id="road-curve" d="M 50 95 L 50 5" stroke="white" stroke-width="8" fill="none" stroke-linecap="round" style="transition: d 0.5s ease-in-out;"></path>
                </svg>
                <div class="text-center mt-4">
                    <p id="curve-type-text" class="text-2xl font-bold">Recta</p>
                    <p id="recommended-speed-text" class="text-lg opacity-80">Velocidad recomendada: --</p>
                    <p id="distance-to-curve-text" class="text-lg mt-2 opacity-80">Distancia a curva: -- m</p> <!-- Nuevo elemento para la distancia -->
                </div>
            </div>

            <!-- Sección Media: Velocidad y Alerta -->
            <div class="text-center">
                <p id="alert-text" class="text-3xl font-black tracking-wider uppercase">INICIANDO GPS</p>
                <p id="speed-text" class="text-8xl font-bold">0</p>
                <p class="text-2xl font-bold -mt-2">km/h</p>
            </div>
            
            <!-- Sección Inferior: Estado -->
            <div class="w-full mt-auto h-10 flex items-center justify-center">
                <div id="location-status" class="text-center text-sm opacity-80 status-pulse">Buscando señal de GPS...</div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN Y CONSTANTES ---
        const RECOMMENDED_SPEEDS = { straight: 120, open: 90, closed: 60 };
        const OVERPASS_API_URL = "https://overpass-api.de/api/interpreter";
        const ANALYSIS_RADIUS_METERS = 400; // Radio de búsqueda de carreteras
        const ANALYSIS_INTERVAL_MS = 10000; // Consultar OSM cada 10 segundos
        const MIN_MOVEMENT_METERS = 50; // Solo analizar si nos hemos movido más de 50 metros

        // Umbrales de alerta según el modo de conducción
        const ALERT_THRESHOLDS = {
            comfort: {
                warning: 1.05, // 5% por encima de la velocidad recomendada
                danger: 1.10  // 10% por encima de la velocidad recomendada
            },
            sport: { 
                warning: 1.10, // 10% por encima de la velocidad recomendada
                danger: 1.20  // 20% por encima de la velocidad recomendada
            }
        };

        // --- REFERENCIAS A ELEMENTOS DEL DOM ---
        const appScreen = document.getElementById('app-screen');
        const speedText = document.getElementById('speed-text');
        const alertText = document.getElementById('alert-text');
        const roadCurve = document.getElementById('road-curve');
        const curveTypeText = document.getElementById('curve-type-text');
        const recommendedSpeedText = document.getElementById('recommended-speed-text');
        const distanceToCurveText = document.getElementById('distance-to-curve-text'); // Nueva referencia
        const locationStatus = document.getElementById('location-status');

        // Seleccionamos solo los botones de modo existentes
        const modeButtons = document.querySelectorAll('.mode-button'); 

        // --- ESTADO GLOBAL DE LA APP ---
        let state = {
            currentSpeed: 0.0,
            curveType: 'straight', // 'straight', 'open', 'closed'
            currentLat: null,
            currentLon: null,
            lastAnalysisLat: null,
            lastAnalysisLon: null,
            isAnalyzing: false,
            currentAlertLevel: 'initializing', // 'initializing', 'safe', 'warning', 'danger'
            drivingMode: 'comfort', // Modo de conducción inicial: 'comfort', 'sport'
            detectedCurvePoint: null, // Almacena el punto clave de la curva detectada
            detectedCurveDirection: 'none', // 'left', 'right', 'none'
        };

        // --- LÓGICA DE SONIDOS (Web Audio API) ---
        let audioContext;
        let currentOscillator = null;

        /**
         * Inicializa el AudioContext si aún no se ha hecho.
         * Se inicializa al primer gesto del usuario (por ejemplo, clic o toque).
         */
        function initializeAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        /**
         * Reproduce un pitido con la frecuencia, duración y volumen especificados.
         * Detiene cualquier pitido anterior antes de iniciar uno nuevo.
         * @param {number} frequency - Frecuencia del pitido en Hz.
         * @param {number} duration - Duración del pitido en segundos.
         * @param {number} volume - Volumen del pitido (0.0 a 1.0).
         */
        function playBeep(frequency, duration, volume) {
            initializeAudioContext(); // Asegura que el contexto de audio esté inicializado

            // Detener el oscilador actual si existe
            if (currentOscillator) {
                currentOscillator.stop();
                currentOscillator.disconnect();
                currentOscillator = null;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sine'; // Tipo de onda: 'sine', 'square', 'sawtooth', 'triangle'
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            // Detener el oscilador después de la duración especificada
            oscillator.stop(audioContext.currentTime + duration);

            // Mantener una referencia al oscilador para poder detenerlo antes si es necesario
            currentOscillator = oscillator;
        }

        /**
         * Detiene cualquier pitido que se esté reproduciendo.
         */
        function stopBeep() {
            if (currentOscillator) {
                currentOscillator.stop();
                currentOscillator.disconnect();
                currentOscillator = null;
            }
        }

        // Event listener para inicializar el contexto de audio con la primera interacción del usuario
        // Esto es necesario en muchos navegadores para que el audio funcione.
        document.addEventListener('click', initializeAudioContext, { once: true });
        document.addEventListener('touchstart', initializeAudioContext, { once: true });


        // --- LÓGICA DE LA INTERFAZ ---
        function updateUI() {
            const recommendedSpeed = RECOMMENDED_SPEEDS[state.curveType];
            const thresholds = ALERT_THRESHOLDS[state.drivingMode]; // Obtener umbrales para el modo actual
            let newAlertLevel = 'safe'; // Valor por defecto

            // Determinar nivel de alerta basado en el modo de conducción
            if (state.currentSpeed > recommendedSpeed * thresholds.danger) {
                newAlertLevel = 'danger';
            } else if (state.currentSpeed > recommendedSpeed * thresholds.warning) {
                newAlertLevel = 'warning';
            }

            // Si el GPS no se ha activado, mantenemos el estado inicial
            if (state.currentLat === null) {
                appScreen.style.backgroundColor = '#3b82f6'; // blue-500
                alertText.textContent = 'INICIANDO GPS';
                newAlertLevel = 'initializing'; // Cambiar el nivel de alerta para que no suene
            }

            // Actualizar color de fondo y texto de alerta
            switch (newAlertLevel) {
                case 'danger':
                    appScreen.style.backgroundColor = '#ef4444'; // red-500
                    alertText.textContent = `PELIGRO! REDUCIR A ${recommendedSpeed} KM/H`;
                    break;
                case 'warning':
                    appScreen.style.backgroundColor = '#f97316'; // orange-500
                    alertText.textContent = `REDUCIR A ${recommendedSpeed} KM/H`;
                    break;
                case 'safe':
                    appScreen.style.backgroundColor = '#22c55e'; // green-500
                    alertText.textContent = 'VELOCIDAD SEGURA';
                    break;
                case 'initializing':
                    // Ya manejado arriba
                    break;
            }
            
            // Lógica de sonido: solo reproducir si el nivel de alerta ha cambiado
            if (newAlertLevel !== state.currentAlertLevel) {
                if (newAlertLevel === 'warning') {
                    stopBeep(); // Asegura que el pitido anterior se detenga
                    playBeep(800, 0.3, 0.7); // Pitido más agudo para advertencia
                } else if (newAlertLevel === 'danger') {
                    stopBeep(); // Asegura que el pitido anterior se detenga
                    playBeep(400, 0.5, 0.8); // Pitido más grave y largo para peligro
                } else if (newAlertLevel === 'safe' || newAlertLevel === 'initializing') {
                    stopBeep(); // Detener el sonido si estamos seguros o inicializando
                }
            }
            state.currentAlertLevel = newAlertLevel; // Actualizar el nivel de alerta actual

            // Actualizar texto de velocidad
            speedText.textContent = Math.round(state.currentSpeed);

            // Actualizar texto de distancia a la curva
            if (state.curveType !== 'straight' && state.detectedCurvePoint && state.currentLat !== null) {
                const dist = getDistance(state.currentLat, state.currentLon, state.detectedCurvePoint.lat, state.detectedCurvePoint.lon);
                distanceToCurveText.textContent = `Distancia a curva: ${Math.round(dist)} m`;
            } else {
                distanceToCurveText.textContent = `Distancia a curva: -- m`;
            }
        }

        // --- NÚCLEO DE GEOLOCALIZACIÓN ---
        function startGeolocation() {
            if (!('geolocation' in navigator)) {
                locationStatus.textContent = "Geolocalización no soportada.";
                return;
            }

            navigator.geolocation.watchPosition(
                (position) => {
                    if (locationStatus.classList.contains('status-pulse')) {
                        locationStatus.classList.remove('status-pulse');
                    }
                    locationStatus.textContent = "GPS Activo";

                    state.currentLat = position.coords.latitude;
                    state.currentLon = position.coords.longitude;
                    // La velocidad en position.coords.speed está en metros/segundo, la convertimos a km/h
                    const speedInMps = position.coords.speed;
                    state.currentSpeed = speedInMps !== null && speedInMps !== undefined ? speedInMps * 3.6 : 0;
                    
                    updateUI(); // Actualiza la UI con la nueva velocidad
                },
                (error) => {
                    locationStatus.textContent = `Error de GPS: ${error.message}`;
                    locationStatus.classList.add('status-pulse');
                    state.currentLat = null; // Resetear coordenadas en caso de error
                    state.currentLon = null;
                    state.currentSpeed = 0;
                    state.currentAlertLevel = 'initializing'; // Volver al estado inicial
                    updateUI(); // Asegurarse de que la UI refleje el error
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        // --- LÓGICA DE ANÁLISIS AUTOMÁTICO CON OPENSTREETMAP ---

        // Función principal del bucle de análisis
        async function analysisLoop() {
            if (state.isAnalyzing || state.currentLat === null) {
                return; // Evita análisis simultáneos o sin coordenadas
            }

            // Comprueba si nos hemos movido lo suficiente desde el último análisis
            const movedDistance = state.lastAnalysisLat ?
                getDistance(state.currentLat, state.currentLon, state.lastAnalysisLat, state.lastAnalysisLon) :
                MIN_MOVEMENT_METERS + 1; // Forzar el primer análisis

            if (movedDistance < MIN_MOVEMENT_METERS) {
                    return; // No nos hemos movido lo suficiente, esperamos al siguiente ciclo
            }

            state.isAnalyzing = true;
            locationStatus.textContent = "Analizando mapa...";

            try {
                // Construir y ejecutar la consulta a Overpass
                // Se buscan carreteras (highways) de tipos principales alrededor de la ubicación actual.
                const query = `[out:json];(way["highway"~"^(primary|secondary|tertiary|trunk|motorway|unclassified|residential)(_link)?$"](around:${ANALYSIS_RADIUS_METERS},${state.currentLat},${state.currentLon}););out geom;`;
                const response = await fetch(OVERPASS_API_URL, {
                    method: 'POST',
                    body: "data=" + encodeURIComponent(query)
                });
                if (!response.ok) throw new Error(`El servidor de OSM respondió con el estado ${response.status}`);
                
                const data = await response.json();
                
                // Analizar la geometría recibida
                const detectedCurve = analyzeRoadGeometry(data.elements);
                state.curveType = detectedCurve.type;
                state.detectedCurvePoint = detectedCurve.point; // Almacena el punto clave de la curva
                state.detectedCurveDirection = detectedCurve.direction; // Almacena la dirección de la curva
                
                // Actualizar UI con el resultado del análisis
                updateCurveDisplay(detectedCurve.type, detectedCurve.direction); // Pasar la dirección

                // Guardar la ubicación de este análisis
                state.lastAnalysisLat = state.currentLat;
                state.lastAnalysisLon = state.currentLon;

            } catch (error) {
                locationStatus.textContent = `Error de red: ${error.message}`;
            } finally {
                setTimeout(() => {
                    if(state.currentLat !== null) { // Solo si el GPS sigue activo
                        locationStatus.textContent = "GPS Activo";
                    }
                }, 2000); // Volver al estado "GPS Activo" después de un breve retraso
                state.isAnalyzing = false;
            }
        }
        
        // Algoritmo (simplificado) para analizar la geometría
        // Busca el ángulo más cerrado entre segmentos de carretera y determina su dirección.
        function analyzeRoadGeometry(elements) {
            let sharpestAngle = 180; // Empezamos con una recta (ángulo máximo)
            let curvePoint = null; // Almacena el punto del vértice de la curva más cerrada
            let curveDirection = 'none'; // 'left', 'right', 'none'

            for (const el of elements) {
                if (el.type !== 'way' || !el.geometry || el.geometry.length < 3) continue;
                
                for (let i = 1; i < el.geometry.length - 1; i++) {
                    const pA = el.geometry[i - 1];
                    const pB = el.geometry[i];
                    const pC = el.geometry[i + 1];
                    
                    const angle = getAngle(pA, pB, pC);
                    if (angle < sharpestAngle) {
                        sharpestAngle = angle;
                        curvePoint = pB; // Guarda el vértice de la curva más pronunciada

                        // Determinar la dirección de la curva (izquierda/derecha)
                        // Se usa un producto cruzado simple para aproximar la dirección en coordenadas lat/lon.
                        // Un valor positivo sugiere una curva a la izquierda, negativo a la derecha.
                        const crossProduct = (pB.lon - pA.lon) * (pC.lat - pB.lat) - (pB.lat - pA.lat) * (pC.lon - pB.lon);
                        if (crossProduct > 0.0001) { // Pequeña tolerancia para errores de punto flotante
                            curveDirection = 'left';
                        } else if (crossProduct < -0.0001) {
                            curveDirection = 'right';
                        } else {
                            curveDirection = 'none'; // Segmento recto o casi recto
                        }
                    }
                }
            }

            let type = 'straight';
            if (sharpestAngle < 165) {
                type = 'closed';
            } else if (sharpestAngle < 175) {
                type = 'open';
            }
            return { type: type, angle: sharpestAngle, point: curvePoint, direction: curveDirection };
        }

        // Actualiza el icono SVG de la curva y el texto de velocidad recomendada
        function updateCurveDisplay(type, direction) {
            const speed = RECOMMENDED_SPEEDS[type];
            recommendedSpeedText.textContent = `Recomendada: ${speed} km/h`;
            
            switch (type) {
                case 'closed':
                    // SVG para curva cerrada, ajustando la dirección
                    roadCurve.setAttribute('d', direction === 'right' ? 'M 50 95 Q 110 50 50 5' : 'M 50 95 Q -10 50 50 5');
                    curveTypeText.textContent = 'Curva Cerrada';
                    break;
                case 'open':
                    // SVG para curva abierta, ajustando la dirección
                    roadCurve.setAttribute('d', direction === 'right' ? 'M 50 95 Q 70 50 50 5' : 'M 50 95 Q 30 50 50 5');
                    curveTypeText.textContent = 'Curva Abierta';
                    break;
                case 'straight':
                default:
                    // SVG para carretera recta
                    roadCurve.setAttribute('d', 'M 50 95 L 50 5');
                    curveTypeText.textContent = 'Recta';
                    break;
            }
            updateUI(); // Refrescar la UI después de cambiar el tipo de curva
        }

        // --- FUNCIONES MATEMÁTICAS AUXILIARES ---
        
        // Calcula la distancia entre dos puntos GPS en metros (Fórmula de Haversine)
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Radio de la Tierra en metros
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                        Math.cos(φ1) * Math.cos(φ2) *
                        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calcula el ángulo formado por 3 puntos (Punto B es el vértice)
        function getAngle(A, B, C) {
            const vBA = { lat: A.lat - B.lat, lon: A.lon - B.lon };
            const vBC = { lat: C.lat - B.lat, lon: C.lon - B.lon };
            const dotProduct = vBA.lat * vBC.lat + vBA.lon * vBC.lon;
            const magBA = Math.sqrt(vBA.lat * vBA.lat + vBA.lon * vBA.lon);
            const magBC = Math.sqrt(vBC.lat * vBC.lat + vBC.lon * vBC.lon);
            // Evitar división por cero si magBA o magBC son cero
            if (magBA === 0 || magBC === 0) return 180; // Considerar línea recta si un punto es igual al otro

            const angleRad = Math.acos(Math.max(-1, Math.min(1, dotProduct / (magBA * magBC)))); // Clamp para evitar NaN por errores de punto flotante
            return angleRad * 180 / Math.PI; // Convertir a grados
        }

        // --- MANEJO DE MODOS DE CONDUCCIÓN ---
        function setDrivingMode(mode) {
            // Eliminar la clase 'selected' de todos los botones
            modeButtons.forEach(button => button.classList.remove('selected'));
            // Añadir la clase 'selected' al botón actual
            document.getElementById(`mode-${mode}`).classList.add('selected');
            state.drivingMode = mode; // Actualizar el estado
            updateUI(); // Forzar una actualización de la UI para aplicar los nuevos umbrales
        }

        // Añadir Event Listeners a los botones de modo
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                setDrivingMode(button.dataset.mode);
            });
        });

        // --- INICIALIZACIÓN ---
        updateUI(); // Establece la UI inicial
        startGeolocation(); // Pide permisos y empieza a escuchar el GPS
        setInterval(analysisLoop, ANALYSIS_INTERVAL_MS); // Inicia el bucle de análisis automático

        // Establecer el modo inicial (Confort por defecto)
        setDrivingMode(state.drivingMode);
    </script>
</body>
</html>
